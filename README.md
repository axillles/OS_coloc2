# Коллоквиум 2 по ОС: Шаблон Singleton с ортогональными стратегиями

Этот проект реализует мощный и гибкий шаблон проектирования Singleton на C++ с использованием ортогональных стратегий, описанных в главе 6 книги Андрея Александреску *Modern C++ Design* и вдохновленных библиотекой Loki. Реализация разделяет ответственность на независимые политики управления созданием, синхронизацией и временем жизни объекта, с акцентом на потокобезопасность для многопоточных сред.

## Возможности

- **Ортогональные политики**:
  - **Политика создания**: Управляет созданием и уничтожением объекта (по умолчанию: `new`/`delete`).
  - **Политика синхронизации**: Обеспечивает потокобезопасность с использованием двойной проверки блокировки с `std::mutex` и `std::atomic`.
  - **Политика времени жизни**: Контролирует жизненный цикл Singleton (по умолчанию: уничтожение при завершении программы через `std::atexit`).
- **Современный C++**: Использует возможности C++11+ (`std::mutex`, `std::atomic`, шаблоны).
- **Расширяемость**: Легко настраивается путем определения новых политик.
- **Потокобезопасность**: Оптимизирован для многопоточных сред с минимальными накладными расходами на блокировку.

## Файлы

- `singleton.hpp`: Заголовочный файл, содержащий шаблон Singleton и реализации политик.
- `main.cpp`: Пример использования Singleton с простым классом `Example`.

## Требования

- Компилятор, совместимый с C++11 или новее (например, `g++`, `clang++`, MSVC).
- Стандартная библиотека C++ с поддержкой `<mutex>`, `<atomic>` и `<memory>`.

## Инструкции по сборке

1. Клонируйте репозиторий:

   ```bash
   git clone git@github.com:axillles/OS_coloc2.git
   cd OS_coloc2
   ```

2. Скомпилируйте код:

   ```bash
   g++ -std=c++11 main.cpp -o singleton
   ```

3. Запустите программу:

   ```bash
   ./singleton
   ```

## Пример использования

Файл `main.cpp` демонстрирует, как использовать Singleton:

```cpp
#include "singleton.hpp"
#include <iostream>

class Example {
public:
    void print() const {
        std::cout << "Экземпляр Singleton по адресу " << this << std::endl;
    }
};

int main() {
    Example& instance1 = Singleton<Example>::instance();
    instance1.print();

    Example& instance2 = Singleton<Example>::instance();
    instance2.print(); // Должен вывести тот же адрес
    return 0;
}
```

Ожидаемый вывод:

```
Экземпляр Singleton по адресу 0x...
Экземпляр Singleton по адресу 0x...  // Тот же адрес
```

## Расширение Singleton

Для настройки Singleton определите новые политики:

- **Политика создания**: Реализуйте новый класс с методами `static T* create()` и `static void destroy(T*)`.
- **Политика синхронизации**: Создайте новый класс с методом `static std::mutex& get_mutex()`.
- **Политика времени жизни**: Определите новый класс с методом `static void schedule_destruction(T*, void (*)())`.

Пример пользовательской политики:

```cpp
template <typename T>
struct CustomCreationPolicy {
    static T* create() { return new T(42); } // Пользовательский конструктор
    static void destroy(T* obj) { delete obj; }
};

using CustomSingleton = Singleton<Example, CustomCreationPolicy>;
```

## Вклад в проект

Приглашаем отправлять сообщения об ошибках или запросы на включение изменений в репозиторий по адресу `git@github.com:axillles/OS_coloc2.git`.

## Лицензия

Проект распространяется под лицензией MIT.